"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var minify_html_exports = {};
__export(minify_html_exports, {
  default: () => createMinifyPlugin
});
module.exports = __toCommonJS(minify_html_exports);
var import_html_minifier_terser = require("html-minifier-terser");
var import_pluginutils = require("@rollup/pluginutils");
var PLUGIN_NAME = "vite-plugin-minify-html";
var htmlFilter = (0, import_pluginutils.createFilter)(["**/*.html"]);
function minifyOptions(options) {
  const opts = options === true ? {} : options;
  return {
    collapseWhitespace: true,
    keepClosingSlash: true,
    removeComments: true,
    removeRedundantAttributes: true,
    removeScriptTypeAttributes: true,
    removeStyleLinkTypeAttributes: true,
    useShortDoctype: true,
    minifyCSS: true,
    ...opts
  };
}
async function minifyHtml(html, minify) {
  if (typeof minify === "boolean" && !minify) {
    return html;
  }
  return await (0, import_html_minifier_terser.minify)(html, minifyOptions(minify));
}
function createMinifyPlugin(minify) {
  return {
    name: PLUGIN_NAME,
    enforce: "post",
    // apply: 'build' as const,
    async generateBundle(_, outputBundle) {
      if (minify) {
        for (const bundle of Object.values(outputBundle)) {
          if (bundle.type === "asset" && htmlFilter(bundle.fileName) && typeof bundle.source === "string") {
            bundle.source = await minifyHtml(bundle.source, minify);
          }
        }
      }
    }
  };
}
