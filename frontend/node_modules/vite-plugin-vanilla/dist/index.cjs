"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => createPlugin
});
module.exports = __toCommonJS(src_exports);
var import_vite_plugin_minify_html = __toESM(require("vite-plugin-minify-html"), 1);

// src/vanillaPlugin.ts
var import_promises = __toESM(require("fs/promises"), 1);
var import_pathe = __toESM(require("pathe"), 1);
var import_fast_glob = __toESM(require("fast-glob"), 1);

// src/utils.ts
var vite = __toESM(require("vite"), 1);
var import_diy_log = require("diy-log");
var PLUGIN_NAME = "vite-plugin-vanilla";
var getPageRE = (suffix, end = true) => {
  const suffixStr = Array.isArray(suffix) ? suffix.join("|") : suffix;
  return new RegExp(`\\.(${suffixStr})${end ? "$" : ""}`, "i");
};
function errlog(...args) {
  (0, import_diy_log.error)(`[${import_diy_log.colors.gray(PLUGIN_NAME)}] `, ...args);
}
function getViteVersion() {
  return vite?.version ? Number(vite.version.split(".")[0]) : 2;
}
function cleanUrl(url) {
  if (!url) return "/";
  const queryRE = /\?.*$/s;
  const hashRE = /#.*$/s;
  return url.replace(hashRE, "").replace(queryRE, "");
}
function cleanPageUrl(path2, reg) {
  const result = path2.replace(/(^\/)|(\/$)/g, "");
  return reg ? result.replace(reg, "") : result;
}

// src/vanillaPlugin.ts
var import_mv_file = require("mv-file");
var defaults = {
  include: "src/**/*.html",
  exclude: [],
  suffix: "html",
  base: "src",
  minify: true,
  // transform: ()=>{},
  inject: { data: {}, tags: [] },
  replaceDefine: true
};
function createVanillaPlugin(options = {}) {
  const htmlPages = {};
  let viteConfig;
  const opts = Object.assign({}, defaults, options);
  const pageRE = getPageRE(opts.suffix);
  const pagePathRE = getPageRE(opts.suffix, false);
  const basePathResolve = import_pathe.default.resolve(opts.base);
  const transformIndexHtmlHandler = async (html, ctx) => {
    try {
      if (opts.replaceDefine && viteConfig.define) {
        for (const key in viteConfig.define) {
          const _value = viteConfig.define[key];
          const keyReg = new RegExp(key.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g");
          html = html.replace(keyReg, typeof _value === "string" ? JSON.parse(_value) : _value);
        }
      }
      if (typeof opts.transform === "function") {
        html = await opts.transform(html, ctx);
      }
    } catch (err) {
      errlog(err.message);
    }
    return {
      html,
      tags: opts.inject?.tags || []
    };
  };
  return {
    name: PLUGIN_NAME,
    configResolved(resolvedConfig) {
      viteConfig = resolvedConfig;
    },
    config(config) {
      const input = {};
      const files = import_fast_glob.default.sync(opts.include, { ignore: opts.exclude });
      files.forEach((file) => {
        if (!pageRE.test(file)) return;
        const absolutePath = import_pathe.default.resolve(file);
        const relativePath = import_pathe.default.relative(
          import_pathe.default.join(config?.root ?? process.cwd(), opts.base),
          absolutePath
        );
        const fileUrl = cleanPageUrl(relativePath, pageRE);
        input[fileUrl] = absolutePath;
        htmlPages[fileUrl] = {
          file,
          //文件路径
          path: fileUrl,
          //访问路径
          filePath: absolutePath,
          // 绝对路径
          output: relativePath
          // 输出路径
        };
      });
      return {
        appType: "mpa",
        build: {
          rollupOptions: {
            input
          }
        }
      };
    },
    configureServer(server) {
      server.middlewares.use(async (req, res, next) => {
        let url = cleanUrl(req.url ?? req.originalUrl ?? "");
        const baseDir = viteConfig.base;
        if (baseDir && url.startsWith(baseDir)) {
          url = url.substring(baseDir.length);
        }
        url = cleanPageUrl(url, pageRE);
        if (url === "") {
          url = "index";
        }
        const pageData = pagePathRE.test(req.url || "") ? htmlPages[url] : htmlPages[url] || htmlPages[`${url}/index`];
        if (pageData) {
          try {
            const html = await import_promises.default.readFile(pageData.filePath, "utf-8");
            const transformedHtml = await server.transformIndexHtml(
              req.url || `/${url}`,
              html,
              req.originalUrl
            );
            res.setHeader("Content-Type", "text/html");
            return res.end(transformedHtml);
          } catch (err) {
            errlog(err.message);
            return next(err);
          }
        }
        next();
      });
      const watcher = server.watcher;
      Object.values(htmlPages).forEach(({ filePath }) => {
        watcher.add(filePath);
      });
      function handleChangeFile(_file) {
        server.ws.send({
          type: "full-reload",
          path: "*"
        });
      }
      function handleAddFile(file) {
        const _path = import_pathe.default.resolve(file);
        if (_path.includes(basePathResolve) && pageRE.test(_path)) {
          server.restart();
        }
      }
      watcher.on("change", handleChangeFile);
      watcher.on("unlink", handleChangeFile);
      watcher.on("add", handleAddFile);
    },
    transformIndexHtml: getViteVersion() < 5 ? {
      enforce: "pre",
      transform: transformIndexHtmlHandler
    } : {
      order: "pre",
      handler: transformIndexHtmlHandler
    },
    closeBundle() {
      const dest = viteConfig.build.outDir || "dist";
      const files = Object.values(htmlPages).reduce((acc, page) => {
        const _src = import_pathe.default.join(dest, page.file);
        acc[_src] = page.output;
        return acc;
      }, {});
      (0, import_mv_file.moveFile)(files, { base: dest, dest, clean: true, force: true });
    }
  };
}

// src/index.ts
function createPlugin(options = {}) {
  if (typeof options === "string" || Array.isArray(options)) {
    options = { include: options };
  }
  const opts = Object.assign({ minify: true }, options);
  const plugins = [createVanillaPlugin(opts)];
  if (opts.minify) {
    plugins.push((0, import_vite_plugin_minify_html.default)(opts.minify));
  }
  return plugins;
}
